---
title: "[2026 동계 모각코] 2026-01-13 결과 (4회차)"
image: "/images/mogakco_9.png"
date: "2026-01-13"
category: "mogakco"
tags: ["모각코"]
summary: ""
draft: false
---

## 목표
- 목표: 위험 키워드/확장자 규칙 태깅
- 진행 내용
    - 태깅 규칙 적용
        - 확장자: exe, dll, ps1, bat, vbs, js, jar, iso, img, zip, 7z 등
        - 키워드: invoice, crack, keygen, patch, install, update 등
        - URL 도메인/스키마: raw, paste, ip direct, http 등
    - risk_tag, risk_reason 컬럼 추가

## 진행 내용

### 태깅 규칙 적용

다운로드 파일의 위험도를 평가하기 위한 규칙 기반 태깅 시스템을 설계하고 구현했다. 파일 확장자, 파일명 키워드, URL 패턴의 세 가지 기준으로 위험도를 판단한다.

#### 위험 확장자 규칙

실행 가능한 파일이나 악성코드 배포에 자주 사용되는 확장자를 위험 목록으로 정의했다.

```python
# 위험 확장자 분류
RISK_EXTENSIONS = {
    "critical": {
        "exe", "dll", "scr", "pif", "com",  # Windows 실행 파일
        "ps1", "psm1", "psd1",              # PowerShell 스크립트
        "bat", "cmd",                        # Batch 스크립트
        "vbs", "vbe", "js", "jse", "wsf",   # 스크립트 파일
        "hta", "msi", "msp",                # 설치 파일
    },
    "high": {
        "jar", "class",                      # Java 실행 파일
        "iso", "img", "vhd", "vhdx",        # 디스크 이미지
        "lnk",                               # 바로가기 (악용 가능)
    },
    "medium": {
        "zip", "7z", "rar", "tar", "gz",    # 압축 파일
        "docm", "xlsm", "pptm",             # 매크로 포함 Office
        "pdf",                               # PDF (스크립트 포함 가능)
    }
}
```

#### 의심 키워드 규칙

파일명에 포함된 키워드를 기반으로 피싱이나 악성코드 가능성을 탐지한다.

```python
# 의심 키워드 분류
SUSPICIOUS_KEYWORDS = {
    "critical": [
        "crack", "keygen", "patch", "activator", "loader",
        "hack", "cheat", "exploit",
    ],
    "high": [
        "invoice", "payment", "receipt", "order",
        "urgent", "confirm", "verify", "suspended",
        "password", "credential", "login",
    ],
    "medium": [
        "install", "setup", "update", "driver",
        "free", "download", "portable",
    ]
}
```

#### URL 패턴 규칙

다운로드 URL의 특성을 분석하여 위험도를 평가한다.

```python
import re
from urllib.parse import urlparse

# 위험 URL 패턴
URL_PATTERNS = {
    "critical": [
        r"^https?://\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}",  # IP 직접 접속
        r"pastebin\.com", r"paste\.", r"raw\.",            # 코드 공유 사이트
        r"anonfiles\.", r"mediafire\.", r"zippyshare\.",   # 파일 공유 사이트
    ],
    "high": [
        r"^http://",                                        # 비암호화 HTTP
        r"bit\.ly", r"tinyurl\.", r"t\.co",                # 단축 URL
        r"drive\.google\.com.*export",                     # 직접 다운로드 링크
    ],
    "medium": [
        r"github\.com.*releases",                          # GitHub 릴리즈
        r"sourceforge\.net",                               # SourceForge
    ]
}


def check_url_risk(url):
    """URL 위험도 검사"""
    if not url:
        return None, None

    for level in ["critical", "high", "medium"]:
        for pattern in URL_PATTERNS[level]:
            if re.search(pattern, url, re.IGNORECASE):
                return level, f"URL 패턴 매칭: {pattern}"

    return None, None
```

### risk_tag, risk_reason 컬럼 추가

위험도 평가 결과를 저장하기 위한 `risk_tag`와 `risk_reason` 필드를 추가했다.

#### 위험도 평가 함수

```python
def evaluate_risk(filename, extension, url):
    """종합 위험도 평가

    Args:
        filename: 파일명
        extension: 확장자
        url: 다운로드 URL

    Returns:
        tuple: (risk_tag, risk_reasons)
            - risk_tag: "critical", "high", "medium", "low", "safe"
            - risk_reasons: 위험 판단 사유 리스트
    """
    reasons = []
    max_level = "safe"
    level_priority = {"critical": 4, "high": 3, "medium": 2, "low": 1, "safe": 0}

    # 1. 확장자 검사
    ext_lower = extension.lower() if extension else ""
    for level, extensions in RISK_EXTENSIONS.items():
        if ext_lower in extensions:
            reasons.append(f"위험 확장자: .{ext_lower} ({level})")
            if level_priority[level] > level_priority[max_level]:
                max_level = level
            break

    # 2. 키워드 검사
    filename_lower = filename.lower() if filename else ""
    for level, keywords in SUSPICIOUS_KEYWORDS.items():
        for keyword in keywords:
            if keyword in filename_lower:
                reasons.append(f"의심 키워드: {keyword} ({level})")
                if level_priority[level] > level_priority[max_level]:
                    max_level = level
                break

    # 3. URL 검사
    url_level, url_reason = check_url_risk(url)
    if url_level:
        reasons.append(url_reason)
        if level_priority[url_level] > level_priority[max_level]:
            max_level = url_level

    # 위험 요소가 없으면 safe
    if not reasons:
        return "safe", ["위험 요소 없음"]

    return max_level, reasons
```

#### 출력 포맷 업데이트

위험도 정보를 콘솔 출력에 포함하도록 수정했다.

```python
# 위험도별 색상 코드 (ANSI)
RISK_COLORS = {
    "critical": "\033[91m",  # 빨강
    "high": "\033[93m",      # 노랑
    "medium": "\033[94m",    # 파랑
    "low": "\033[90m",       # 회색
    "safe": "\033[92m",      # 초록
}
RESET_COLOR = "\033[0m"


def print_download_record_with_risk(record):
    """위험도 정보를 포함한 다운로드 기록 출력"""
    id, path, size, start, end, state, danger, mime, referrer, tab_url, opened, url = record

    filename = extract_filename(path)
    ext = extract_extension(filename)

    # 위험도 평가
    risk_tag, risk_reasons = evaluate_risk(filename, ext, url)
    color = RISK_COLORS.get(risk_tag, "")

    print(f"{'='*60}")
    print(f"ID: {id}")
    print(f"File: {filename}")
    print(f"Extension: {ext}")
    print(f"{color}Risk: [{risk_tag.upper()}]{RESET_COLOR}")
    print(f"  Reasons: {', '.join(risk_reasons)}")
    print(f"Size: {format_size(size)}")
    print(f"URL: {safe_get(url)}")
    print(f"Start: {format_datetime(webkit_to_datetime_safe(start))}")
    print(f"State: {STATE_MAP.get(state, 'Unknown')}")
```

#### 위험도 통계 요약

전체 다운로드 기록의 위험도 분포를 요약하는 함수를 추가했다.

```python
def print_risk_summary(downloads):
    """위험도 분포 요약 출력"""
    risk_counts = {"critical": 0, "high": 0, "medium": 0, "low": 0, "safe": 0}
    critical_files = []

    for record in downloads:
        id, path, size, start, end, state, danger, mime, referrer, tab_url, opened, url = record
        filename = extract_filename(path)
        ext = extract_extension(filename)

        risk_tag, reasons = evaluate_risk(filename, ext, url)
        risk_counts[risk_tag] += 1

        if risk_tag == "critical":
            critical_files.append((filename, reasons))

    print(f"\n[Risk Summary]")
    print(f"  Critical: {risk_counts['critical']}")
    print(f"  High:     {risk_counts['high']}")
    print(f"  Medium:   {risk_counts['medium']}")
    print(f"  Low:      {risk_counts['low']}")
    print(f"  Safe:     {risk_counts['safe']}")

    if critical_files:
        print(f"\n[Critical Files]")
        for filename, reasons in critical_files[:5]:
            print(f"  - {filename}")
            for reason in reasons:
                print(f"      {reason}")
```

#### 실행 결과

![위험도 태깅이 적용된 실행 결과](/images/mogakco_9.png)

![Risk Summary 출력 결과](/images/mogakco_10.png)

## 회고

- 확장자, 키워드, URL 세 가지 기준을 조합하여 평가하는 방식을 선택했다. 단일 기준보다 복합 기준이 오탐을 줄이면서도 탐지율을 유지할 수 있다고 판단했다.
- `level_priority` 딕셔너리를 사용해 가장 높은 위험도를 최종 태그로 선택하는 로직을 구현했다. 여러 위험 요소가 동시에 탐지될 때 가장 심각한 수준을 기준으로 분류해야 분석 우선순위를 정할 수 있기 때문이다.
- IP 직접 접속이나 pastebin 같은 URL 패턴을 critical로 분류한 것은 C2 서버 통신이나 악성 페이로드 호스팅에 자주 사용되는 패턴이기 때문이다.
- 다음 회차에서는 시나리오 데이터를 만들어 실제 분석을 수행해볼 예정이다.

