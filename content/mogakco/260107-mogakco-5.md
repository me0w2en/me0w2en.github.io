---
title: "[2026 동계 모각코] 2026-01-07 결과 (2회차)"
image: "/images/mogakco_6.png"
date: "2026-01-07"
category: "mogakco"
tags: ["모각코"]
summary: ""
draft: false
---

## 목표
- 목표: 추출 항목 및 정규화 규칙 확정 + 기본 출력 제작
- 진행 내용
    - 산출 필드 및 정규화 규칙 정의
    - console print 구현

## 진행 내용

### 산출 필드 및 정규화 규칙 정의

1회차에서 분석한 `downloads` 테이블의 컬럼들 중 트리아지에 필요한 핵심 필드를 선정하고, 출력 시 적용할 정규화 규칙을 정의했다.

#### 추출 대상 필드

| 필드명 | 원본 컬럼 | 설명 |
|--------|----------|------|
| `id` | `downloads.id` | 다운로드 고유 식별자 |
| `file_name` | `downloads.target_path` | 파일명 (경로에서 추출) |
| `file_path` | `downloads.target_path` | 전체 저장 경로 |
| `file_ext` | `downloads.target_path` | 파일 확장자 (경로에서 추출) |
| `file_size` | `downloads.total_bytes` | 파일 크기 (bytes) |
| `download_url` | `downloads_url_chains.url` | 다운로드 원본 URL |
| `referrer` | `downloads.referrer` | 다운로드를 시작한 페이지 URL |
| `start_time` | `downloads.start_time` | 다운로드 시작 시간 |
| `end_time` | `downloads.end_time` | 다운로드 완료 시간 |
| `state` | `downloads.state` | 다운로드 상태 |
| `danger_type` | `downloads.danger_type` | 위험 유형 코드 |
| `mime_type` | `downloads.mime_type` | 파일 MIME 타입 |

#### 정규화 규칙

| 필드 | 정규화 방법 |
|------|------------|
| `file_name` | `target_path`에서 마지막 경로 구분자 이후 문자열 추출 |
| `file_ext` | `file_name`에서 마지막 `.` 이후 문자열을 소문자로 변환 |
| `file_size` | bytes를 KB/MB/GB 단위로 변환하여 표시 |
| `start_time` / `end_time` | WebKit timestamp → `YYYY-MM-DD HH:MM:SS` 형식으로 변환 |
| `state` | 숫자 코드 → 문자열 매핑 (0: In Progress, 1: Complete, 2: Cancelled, 3: Interrupted) |
| `danger_type` | 숫자 코드 → 문자열 매핑 (0: Safe, 1: Dangerous, 2: Dangerous URL 등) |
| `download_url` | URL 디코딩 적용 |

#### 상태 코드 매핑 테이블

**Download State**

| 코드 | 상태 |
|------|------|
| 0 | In Progress |
| 1 | Complete |
| 2 | Cancelled |
| 3 | Interrupted |

**Danger Type**

| 코드 | 유형 | 설명 |
|------|------|------|
| 0 | Safe | 안전한 파일 |
| 1 | Dangerous | 위험한 파일 |
| 2 | Dangerous URL | 위험한 URL에서 다운로드 |
| 3 | Dangerous Content | 위험한 콘텐츠 |
| 4 | Maybe Dangerous Content | 잠재적으로 위험한 콘텐츠 |
| 5 | Uncommon Content | 일반적이지 않은 콘텐츠 |
| 6 | User Validated | 사용자가 위험을 확인함 |
| 7 | Dangerous Host | 위험한 호스트 |
| 8 | Potentially Unwanted | 잠재적으로 원치 않는 프로그램 |
| 9 | Allowlisted by Policy | 정책에 의해 허용됨 |

### console print 구현

Python을 사용하여 History DB에서 다운로드 기록을 추출하고 콘솔에 출력하는 기본 스크립트를 작성했다.

#### 프로젝트 구조

```
download-triage/
├── main.py           # 메인 실행 파일
├── db_parser.py      # DB 파싱 모듈
└── formatter.py      # 출력 포맷터 모듈
```

#### 핵심 코드

**db_parser.py** - WebKit timestamp 변환 및 DB 쿼리

```python
import sqlite3
from datetime import datetime, timedelta

# WebKit timestamp 기준점 (1601-01-01)
WEBKIT_EPOCH = datetime(1601, 1, 1)

def webkit_to_datetime(webkit_timestamp):
    """WebKit timestamp를 datetime 객체로 변환"""
    if not webkit_timestamp:
        return None
    seconds = webkit_timestamp / 1_000_000
    return WEBKIT_EPOCH + timedelta(seconds=seconds)

def get_downloads(db_path):
    """History DB에서 다운로드 기록 추출"""
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()

    query = """
    SELECT
        d.id,
        d.target_path,
        d.total_bytes,
        d.start_time,
        d.end_time,
        d.state,
        d.danger_type,
        d.mime_type,
        d.referrer,
        duc.url as download_url
    FROM downloads d
    LEFT JOIN downloads_url_chains duc
        ON d.id = duc.id AND duc.chain_index = 0
    ORDER BY d.start_time DESC
    """

    cursor.execute(query)
    results = cursor.fetchall()
    conn.close()

    return results
```

**formatter.py** - 출력 포맷팅

```python
import os

STATE_MAP = {
    0: "In Progress",
    1: "Complete",
    2: "Cancelled",
    3: "Interrupted"
}

DANGER_MAP = {
    0: "Safe",
    1: "Dangerous",
    2: "Dangerous URL",
    3: "Dangerous Content",
    4: "Maybe Dangerous",
    5: "Uncommon",
    6: "User Validated",
    7: "Dangerous Host",
    8: "Potentially Unwanted",
    9: "Allowlisted"
}

def format_size(bytes_size):
    """바이트를 읽기 쉬운 단위로 변환"""
    if not bytes_size:
        return "Unknown"
    for unit in ['B', 'KB', 'MB', 'GB']:
        if bytes_size < 1024:
            return f"{bytes_size:.1f} {unit}"
        bytes_size /= 1024
    return f"{bytes_size:.1f} TB"

def extract_filename(path):
    """경로에서 파일명 추출"""
    if not path:
        return "Unknown"
    return os.path.basename(path)

def extract_extension(filename):
    """파일명에서 확장자 추출"""
    if not filename or '.' not in filename:
        return ""
    return filename.rsplit('.', 1)[-1].lower()
```

**main.py** - 메인 실행 및 콘솔 출력

```python
from db_parser import get_downloads, webkit_to_datetime
from formatter import *

def print_download_record(record):
    """단일 다운로드 기록 출력"""
    id, path, size, start, end, state, danger, mime, referrer, url = record

    filename = extract_filename(path)
    ext = extract_extension(filename)

    print(f"{'='*60}")
    print(f"ID: {id}")
    print(f"File: {filename}")
    print(f"Extension: {ext}")
    print(f"Size: {format_size(size)}")
    print(f"URL: {url or 'N/A'}")
    print(f"Referrer: {referrer or 'N/A'}")
    print(f"Start: {webkit_to_datetime(start)}")
    print(f"End: {webkit_to_datetime(end)}")
    print(f"State: {STATE_MAP.get(state, 'Unknown')}")
    print(f"Danger: {DANGER_MAP.get(danger, 'Unknown')}")
    print(f"MIME: {mime or 'N/A'}")

if __name__ == "__main__":
    import sys

    if len(sys.argv) < 2:
        print("Usage: python main.py <History DB path>")
        sys.exit(1)

    db_path = sys.argv[1]
    downloads = get_downloads(db_path)

    print(f"\n[Download Triage Report]")
    print(f"Total records: {len(downloads)}\n")

    for record in downloads:
        print_download_record(record)
```

#### 실행 결과

![main.py 실행 결과 - 다운로드 기록 콘솔 출력](/images/mogakco_6.png)

## 회고

- 1회차에서 파악한 DB 구조를 바탕으로 실제 추출할 필드를 선정하는 과정에서 트리아지에 필요한 정보가 무엇인지 고민하게 되었다.
- `danger_type` 코드 매핑을 조사하면서 브라우저가 다운로드 파일의 위험성을 어떻게 판단하는지 이해할 수 있었다.
- 기본 출력 구현은 완료했지만, 현재는 단순 텍스트 출력이라 가독성이 떨어진다. 다음 회차에서 표 형태나 컬러 출력 등 시각화를 개선할 예정이다.
- 파일 경로에서 파일명과 확장자를 추출하는 로직이 Windows/macOS/Linux 경로 구분자를 모두 처리해야 하는 점을 고려해야 한다.
