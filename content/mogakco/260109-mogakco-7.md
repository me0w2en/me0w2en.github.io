---
title: "[2026 동계 모각코] 2026-01-09 결과 (3회차)"
image: "/images/mogakco_7.png"
date: "2026-01-09"
category: "mogakco"
tags: ["모각코"]
summary: ""
draft: false
---

## 목표
- 목표: 다운로드 기록 추출 및 출력 형태 시각화
- 진행 내용
    - Chrome/Edge 모두에서 동작하도록 Downloads 쿼리 예외 처리 추가
    - DB에 들어있는 시간 포맷을 KST(UTC+9)로 변환
    - 변환 실패/NULL 처리 및 검증

## 진행 내용

### Chrome/Edge 모두에서 동작하도록 Downloads 쿼리 예외 처리 추가

Chrome과 Edge는 동일한 Chromium 기반이지만, 버전에 따라 `downloads` 테이블의 스키마가 다를 수 있다. 일부 컬럼이 존재하지 않는 경우에도 정상 동작하도록 예외 처리를 추가했다.

#### 테이블 스키마 확인 함수

```python
def get_table_columns(cursor, table_name):
    """테이블의 컬럼 목록 조회"""
    cursor.execute(f"PRAGMA table_info({table_name})")
    return [row[1] for row in cursor.fetchall()]
```

#### 동적 쿼리 생성

존재하는 컬럼만 SELECT하도록 쿼리를 동적으로 생성한다.

```python
def build_download_query(cursor):
    """사용 가능한 컬럼에 따라 쿼리 동적 생성"""
    available_columns = get_table_columns(cursor, 'downloads')

    # 필수 컬럼
    base_columns = ['id', 'target_path', 'total_bytes', 'start_time', 'end_time', 'state']

    # 선택적 컬럼 (존재하면 포함)
    optional_columns = ['danger_type', 'mime_type', 'referrer', 'tab_url', 'opened']

    select_columns = []
    for col in base_columns:
        if col in available_columns:
            select_columns.append(f'd.{col}')
        else:
            select_columns.append(f'NULL as {col}')

    for col in optional_columns:
        if col in available_columns:
            select_columns.append(f'd.{col}')
        else:
            select_columns.append(f'NULL as {col}')

    return f"""
    SELECT {', '.join(select_columns)},
           duc.url as download_url
    FROM downloads d
    LEFT JOIN downloads_url_chains duc
        ON d.id = duc.id AND duc.chain_index = 0
    ORDER BY d.start_time DESC
    """
```

#### DB 연결 예외 처리

브라우저가 실행 중일 때 DB 파일이 잠겨있는 경우를 처리한다.

```python
import shutil
import tempfile

def safe_connect(db_path):
    """DB 파일을 임시 위치에 복사하여 안전하게 연결"""
    try:
        # 직접 연결 시도
        conn = sqlite3.connect(f"file:{db_path}?mode=ro", uri=True)
        conn.execute("SELECT 1 FROM downloads LIMIT 1")
        return conn
    except sqlite3.OperationalError:
        # 파일이 잠겨있으면 복사 후 연결
        temp_dir = tempfile.mkdtemp()
        temp_path = os.path.join(temp_dir, "History_copy")
        shutil.copy2(db_path, temp_path)
        return sqlite3.connect(temp_path)
```

### DB에 들어있는 시간 포맷을 KST(UTC+9)로 변환

기존 `webkit_to_datetime` 함수는 UTC 기준으로 변환했다. 한국 시간(KST)으로 표시하기 위해 타임존 처리를 추가했다.

#### 기존 코드의 문제점

```python
# 기존: UTC 기준 변환
def webkit_to_datetime(webkit_timestamp):
    if not webkit_timestamp:
        return None
    seconds = webkit_timestamp / 1_000_000
    return WEBKIT_EPOCH + timedelta(seconds=seconds)
```

위 코드는 UTC 시간을 반환하므로 한국에서 실제 다운로드한 시간과 9시간 차이가 발생한다.

#### 개선된 코드

```python
from datetime import datetime, timedelta, timezone

# WebKit timestamp 기준점 (1601-01-01 UTC)
WEBKIT_EPOCH = datetime(1601, 1, 1, tzinfo=timezone.utc)

# 한국 표준시 (UTC+9)
KST = timezone(timedelta(hours=9))

def webkit_to_datetime(webkit_timestamp, tz=KST):
    """WebKit timestamp를 지정된 타임존의 datetime으로 변환

    Args:
        webkit_timestamp: WebKit timestamp (마이크로초)
        tz: 변환할 타임존 (기본값: KST)

    Returns:
        datetime 객체 또는 None
    """
    if not webkit_timestamp:
        return None

    seconds = webkit_timestamp / 1_000_000
    utc_time = WEBKIT_EPOCH + timedelta(seconds=seconds)

    return utc_time.astimezone(tz)


def format_datetime(dt, fmt="%Y-%m-%d %H:%M:%S"):
    """datetime을 문자열로 포맷팅"""
    if dt is None:
        return "N/A"
    return dt.strftime(fmt)
```

#### 변환 결과 비교

| WebKit Timestamp | UTC 변환 | KST 변환 |
|------------------|----------|----------|
| 13380123456789012 | 2026-01-09 01:23:45 | 2026-01-09 10:23:45 |

![KST 변환이 적용된 실행 결과](/images/mogakco_7.png)

### 변환 실패/NULL 처리 및 검증

데이터베이스에서 추출한 값이 NULL이거나 변환에 실패하는 경우를 안전하게 처리한다.

#### NULL 안전 래퍼 함수

```python
def safe_get(value, default="N/A"):
    """NULL 값을 안전하게 처리"""
    if value is None or value == "":
        return default
    return value


def safe_int(value, default=0):
    """정수 변환 실패 시 기본값 반환"""
    try:
        return int(value) if value is not None else default
    except (ValueError, TypeError):
        return default
```

#### 타임스탬프 유효성 검증

WebKit timestamp의 유효 범위를 검증하여 잘못된 값을 필터링한다.

```python
# WebKit timestamp 유효 범위 (2000-01-01 ~ 2100-01-01)
MIN_WEBKIT_TS = 12591158400000000  # 2000-01-01
MAX_WEBKIT_TS = 15778800000000000  # 2100-01-01

def is_valid_webkit_timestamp(ts):
    """WebKit timestamp 유효성 검증"""
    if ts is None:
        return False
    return MIN_WEBKIT_TS <= ts <= MAX_WEBKIT_TS


def webkit_to_datetime_safe(webkit_timestamp, tz=KST):
    """유효성 검증을 포함한 안전한 변환"""
    if not is_valid_webkit_timestamp(webkit_timestamp):
        return None

    try:
        return webkit_to_datetime(webkit_timestamp, tz)
    except (OverflowError, OSError, ValueError):
        return None
```

#### 데이터 무결성 검증 결과 출력

```python
def validate_record(record):
    """레코드 유효성 검증 및 경고 출력"""
    warnings = []

    id, path, size, start, end, state, danger, mime, referrer, url = record

    if not path:
        warnings.append("파일 경로 없음")

    if not is_valid_webkit_timestamp(start):
        warnings.append("시작 시간 유효하지 않음")

    if end and start and end < start:
        warnings.append("종료 시간이 시작 시간보다 이름")

    if size is not None and size < 0:
        warnings.append("파일 크기가 음수")

    return warnings
```

#### 검증 통계 출력

```python
def print_validation_summary(downloads):
    """전체 데이터 검증 요약"""
    total = len(downloads)
    valid = 0
    invalid_records = []

    for record in downloads:
        warnings = validate_record(record)
        if warnings:
            invalid_records.append((record[0], warnings))
        else:
            valid += 1

    print(f"\n[Validation Summary]")
    print(f"Total: {total}, Valid: {valid}, Invalid: {total - valid}")

    if invalid_records:
        print(f"\nInvalid Records:")
        for id, warnings in invalid_records[:5]:  # 상위 5개만 출력
            print(f"  ID {id}: {', '.join(warnings)}")
```

![Validation Summary가 포함된 실행 결과](/images/mogakco_8.png)

## 회고

- Chrome과 Edge의 스키마 차이를 동적으로 처리하는 방식을 구현하면서 방어적 프로그래밍의 중요성을 느꼈다.
- 타임존 처리를 추가하면서 Python의 `datetime`과 `timezone` 모듈 사용법을 익혔다. 포렌식 도구에서 시간 정보는 매우 중요하므로 정확한 타임존 변환이 필수적이다.
- 데이터 유효성 검증을 통해 손상된 레코드나 비정상적인 값을 사전에 필터링할 수 있게 되었다.
- 다음 회차에서는 위험 파일 확장자나 의심 키워드를 기준으로 태깅 기능을 추가할 예정이다.
